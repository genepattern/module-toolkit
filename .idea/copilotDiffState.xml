<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/generate-module.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/generate-module.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;GenePattern Module Generator&#10;&#10;A multi-agent system for automatically generating GenePattern modules from bioinformatics tools.&#10;Uses Pydantic AI to orchestrate research, planning, and artifact generation.&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import traceback&#10;import argparse&#10;from pathlib import Path&#10;from typing import Dict, List, Tuple, Any&#10;from dataclasses import dataclass&#10;from datetime import datetime&#10;&#10;from pydantic_ai import Agent&#10;from pydantic_ai.mcp import MCPServerStdio&#10;from dotenv import load_dotenv&#10;&#10;&#10;# Load environment variables from .env file&#10;load_dotenv()&#10;&#10;&#10;# Import agents&#10;from agents.researcher import researcher_agent&#10;from agents.planner import planner_agent&#10;from wrapper.agent import wrapper_agent&#10;from dockerfile.agent import dockerfile_agent&#10;from paramgroups.agent import paramgroups_agent&#10;from manifest.agent import manifest_agent&#10;from documentation.agent import documentation_agent&#10;from gpunit.agent import gpunit_agent&#10;&#10;&#10;# Configuration&#10;MAX_ARTIFACT_LOOPS = int(os.getenv('MAX_ARTIFACT_LOOPS', '5'))&#10;DEFAULT_OUTPUT_DIR = os.getenv('MODULE_OUTPUT_DIR', './generated-modules')&#10;&#10;&#10;class Logger:&#10;    &quot;&quot;&quot;Logging and display utilities for the module generation process.&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def print_status(message: str, level: str = &quot;INFO&quot;):&#10;        &quot;&quot;&quot;Print status message with timestamp and level&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%H:%M:%S&quot;)&#10;        print(f&quot;[{timestamp}] {level}: {message}&quot;)&#10;&#10;    @staticmethod&#10;    def print_section(title: str):&#10;        &quot;&quot;&quot;Print a section header&quot;&quot;&quot;&#10;        print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;        print(f&quot; {title}&quot;)&#10;        print(&quot;=&quot; * 60)&#10;&#10;&#10;# Status tracking&#10;@dataclass&#10;class ModuleGenerationStatus:&#10;    &quot;&quot;&quot;Track the status of module generation process&quot;&quot;&quot;&#10;    tool_name: str&#10;    module_directory: str&#10;    research_data: Dict[str, Any] = None&#10;    planning_data: Dict[str, Any] = None&#10;    artifacts_status: Dict[str, Dict[str, Any]] = None&#10;    parameters: List[Dict[str, Any]] = None&#10;    error_messages: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.artifacts_status is None: self.artifacts_status = {}&#10;        if self.parameters is None: self.parameters = []&#10;        if self.error_messages is None: self.error_messages = []&#10;        if self.research_data is None: self.research_data = {}&#10;        if self.planning_data is None: self.planning_data = {}&#10;&#10;    @property&#10;    def research_complete(self) -&gt; bool:&#10;        &quot;&quot;&quot;Return True if research data is present&quot;&quot;&quot;&#10;        return bool(self.research_data)&#10;&#10;    @property&#10;    def planning_complete(self) -&gt; bool:&#10;        &quot;&quot;&quot;Return True if planning data is present&quot;&quot;&quot;&#10;        return bool(self.planning_data)&#10;&#10;&#10;class ModuleAgent:&#10;    &quot;&quot;&quot;&#10;    Main orchestrator agent for GenePattern module generation.&#10;    Groups all methods for calling other agents, validation, and reporting.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self, logger: Logger = None, output_dir: str = DEFAULT_OUTPUT_DIR):&#10;        &quot;&quot;&quot;Initialize the module agent with MCP server for validation&quot;&quot;&quot;&#10;        self.logger = logger or Logger()&#10;        self.output_dir = output_dir&#10;&#10;        # Define artifact agents mapping&#10;        self.artifact_agents = {&#10;            'wrapper': {&#10;                'agent': wrapper_agent,&#10;                'filename': 'wrapper.py',&#10;                'validate_tool': 'validate_wrapper',&#10;                'create_method': 'create_wrapper'&#10;            },&#10;            'manifest': {&#10;                'agent': manifest_agent,&#10;                'filename': 'manifest',&#10;                'validate_tool': 'validate_manifest',&#10;                'create_method': 'create_manifest'&#10;            },&#10;            'paramgroups': {&#10;                'agent': paramgroups_agent,&#10;                'filename': 'paramgroups.json',&#10;                'validate_tool': 'validate_paramgroups',&#10;                'create_method': 'create_paramgroups'&#10;            },&#10;            'gpunit': {&#10;                'agent': gpunit_agent,&#10;                'filename': 'test.yml',&#10;                'validate_tool': 'validate_gpunit',&#10;                'create_method': 'create_gpunit'&#10;            },&#10;            'documentation': {&#10;                'agent': documentation_agent,&#10;                'filename': 'README.md',&#10;                'validate_tool': 'validate_documentation',&#10;                'create_method': 'create_documentation'&#10;            },&#10;            'dockerfile': {&#10;                'agent': dockerfile_agent,&#10;                'filename': 'Dockerfile',&#10;                'validate_tool': 'validate_dockerfile',&#10;                'create_method': 'create_dockerfile'&#10;            }&#10;        }&#10;    &#10;    def create_module_directory(self, tool_name: str) -&gt; Path:&#10;        &quot;&quot;&quot;Create and return the module directory path&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        tool_name_clean = tool_name.lower().replace(' ', '_').replace('-', '_')&#10;        module_dir_name = f&quot;{tool_name_clean}_{timestamp}&quot;&#10;        module_path = Path(self.output_dir) / module_dir_name&#10;&#10;        self.logger.print_status(f&quot;Creating module directory: {module_path}&quot;)&#10;        module_path.mkdir(parents=True, exist_ok=True)&#10;        return module_path&#10;    &#10;    def do_research(self, tool_info: Dict[str, str]) -&gt; Tuple[bool, Dict[str, Any]]:&#10;        &quot;&quot;&quot;Run research phase using researcher agent&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Research Phase&quot;)&#10;        self.logger.print_status(&quot;Starting research on tool information&quot;)&#10;        &#10;        try:&#10;            prompt = f&quot;&quot;&quot;&#10;            Research the bioinformatics tool '{tool_info['name']}' and provide comprehensive information.&#10;            &#10;            Known Information:&#10;            - Name: {tool_info['name']}&#10;            - Version: {tool_info['version']}&#10;            - Language: {tool_info['language']}&#10;            - Description: {tool_info.get('description', 'Not provided')}&#10;            - Repository: {tool_info.get('repository_url', 'Not provided')}&#10;            - Documentation: {tool_info.get('documentation_url', 'Not provided')}&#10;            &#10;            Please provide detailed research including:&#10;            1. Tool purpose and scientific applications&#10;            2. Input/output formats and requirements&#10;            3. Parameter analysis and usage patterns&#10;            4. Installation and dependency requirements&#10;            5. Common workflows and use cases&#10;            6. Integration considerations for GenePattern&#10;            &#10;            Focus on information that will help create a complete GenePattern module.&#10;            &quot;&quot;&quot;&#10;            &#10;            result = researcher_agent.run_sync(prompt)&#10;            self.logger.print_status(&quot;Research phase completed successfully&quot;, &quot;SUCCESS&quot;)&#10;            return True, {'research': result.output}&#10;            &#10;        except Exception as e:&#10;            error_msg = f&quot;Research phase failed: {str(e)}&quot;&#10;            self.logger.print_status(error_msg, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return False, {'error': error_msg}&#10;    &#10;    def do_planning(self, tool_info: Dict[str, str], research_data: Dict[str, Any]) -&gt; Tuple[bool, Dict[str, Any]]:&#10;        &quot;&quot;&quot;Run planning phase using planner agent&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Planning Phase&quot;)&#10;        self.logger.print_status(&quot;Starting module planning and parameter analysis&quot;)&#10;        &#10;        try:&#10;            prompt = f&quot;&quot;&quot;&#10;            Create a comprehensive plan for the GenePattern module for '{tool_info['name']}'.&#10;            &#10;            Tool Information:&#10;            - Name: {tool_info['name']}&#10;            - Version: {tool_info['version']}&#10;            - Language: {tool_info['language']}&#10;            - Description: {tool_info.get('description', 'Not provided')}&#10;            &#10;            Research Results:&#10;            {research_data.get('research', 'No research data available')}&#10;            &#10;            Please create:&#10;            1. Detailed parameter definitions with types and descriptions&#10;            2. Module architecture recommendations&#10;            3. Integration strategy for GenePattern&#10;            4. Validation and testing approach&#10;            5. Implementation roadmap&#10;            &#10;            Focus on creating actionable specifications for module development.&#10;            &quot;&quot;&quot;&#10;            &#10;            result = planner_agent.run_sync(prompt)&#10;            self.logger.print_status(&quot;Planning phase completed successfully&quot;, &quot;SUCCESS&quot;)&#10;            return True, {'plan': result.output, 'parameters': []}  # Parameters would be extracted from plan&#10;            &#10;        except Exception as e:&#10;            error_msg = f&quot;Planning phase failed: {str(e)}&quot;&#10;            self.logger.print_status(error_msg, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return False, {'error': error_msg}&#10;    &#10;    def artifact_creation_loop(self, artifact_name: str, tool_info: Dict[str, str], planning_data: Dict[str, Any], module_path: Path, status: ModuleGenerationStatus) -&gt; bool:&#10;        &quot;&quot;&quot;Generate and validate a single artifact using its dedicated agent&quot;&quot;&quot;&#10;        artifact_config = self.artifact_agents[artifact_name]&#10;        agent = artifact_config['agent']&#10;        filename = artifact_config['filename']&#10;        validate_tool = artifact_config['validate_tool']&#10;        create_method = artifact_config['create_method']&#10;        file_path = module_path / filename&#10;        error_report = &quot;&quot;&#10;&#10;        # Initialize artifact status&#10;        status.artifacts_status[artifact_name] = {&#10;            'generated': False,&#10;            'validated': False,&#10;            'attempts': 0,&#10;            'errors': []&#10;        }&#10;&#10;        for attempt in range(1, MAX_ARTIFACT_LOOPS + 1):&#10;            try:&#10;                self.logger.print_status(f&quot;Generating {artifact_name} (attempt {attempt}/{MAX_ARTIFACT_LOOPS})&quot;)&#10;                status.artifacts_status[artifact_name]['attempts'] = attempt&#10;&#10;                # Call the agent's create method with proper parameters&#10;                prompt = f&quot;&quot;&quot;Use the {create_method} tool with the following parameters:&#10;                - tool_info: {tool_info}&#10;                - planning_data: {planning_data}&#10;                - error_report: {error_report}&#10;                - attempt: {attempt}&#10;&#10;                Generate the {artifact_name} artifact for {tool_info['name']}.&quot;&quot;&quot;&#10;                result = agent.run_sync(prompt)&#10;&#10;                # Write content to file&#10;                with open(file_path, 'w') as f:&#10;                    f.write(result.output)&#10;&#10;                status.artifacts_status[artifact_name]['generated'] = True&#10;                self.logger.print_status(f&quot;Generated {filename}&quot;)&#10;&#10;                # Validate using MCP server&#10;                validation_result = self.validate_artifact(str(file_path), validate_tool)&#10;&#10;                if validation_result['success']:&#10;                    status.artifacts_status[artifact_name]['validated'] = True&#10;                    self.logger.print_status(f&quot;✅ Successfully generated and validated {artifact_name}&quot;)&#10;                    return True&#10;                else:&#10;                    error_report = f&quot;Validation failed: {validation_result.get('error', 'Unknown validation error')}&quot;&#10;                    self.logger.print_status(f&quot;❌ {error_report}&quot;)&#10;                    status.artifacts_status[artifact_name]['errors'].append(error_report)&#10;&#10;                    if attempt == MAX_ARTIFACT_LOOPS:&#10;                        return False&#10;&#10;            except Exception as e:&#10;                error_report = f&quot;Error generating {artifact_name}: {str(e)}&quot;&#10;                self.logger.print_status(error_report, &quot;ERROR&quot;)&#10;                status.artifacts_status[artifact_name]['errors'].append(error_report)&#10;&#10;                if attempt == MAX_ARTIFACT_LOOPS:&#10;                    return False&#10;&#10;        return False&#10;&#10;    def validate_artifact(self, file_path: str, validate_tool: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Validate an artifact using the MCP server&quot;&quot;&quot;&#10;        try:&#10;            self.logger.print_status(f&quot;Validating with {validate_tool}&quot;)&#10;&#10;            # Create a temporary agent with MCP tools to run validation&#10;            validation_agent = Agent(&#10;                model='bedrock:us.anthropic.claude-sonnet-4-20250514-v1:0',&#10;                toolsets=[MCPServerStdio('python', args=['mcp/server.py'], timeout=10)]&#10;            )&#10;&#10;            # Use the agent to call the validation tool&#10;            prompt = f&quot;Use the {validate_tool} tool to validate the file at path: {file_path}&quot;&#10;            result = validation_agent.run_sync(prompt)&#10;&#10;            # Check if validation passed&#10;            output = result.output.lower()&#10;            if &quot;pass&quot; in output or &quot;valid&quot; in output or &quot;success&quot; in output:&#10;                return {'success': True, 'result': result.output}&#10;            else:&#10;                return {'success': False, 'error': result.output}&#10;                &#10;        except Exception as e:&#10;            return {'success': False, 'error': f&quot;Validation error: {str(e)}&quot;}&#10;&#10;    def generate_all_artifacts(self, tool_info: Dict[str, str], planning_data: Dict[str, Any], module_path: Path, status: ModuleGenerationStatus, skip_artifacts: List[str] = None) -&gt; bool:&#10;        &quot;&quot;&quot;Run artifact generation phase using artifact agents&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Artifact Generation Phase&quot;)&#10;        self.logger.print_status(&quot;Starting artifact generation&quot;)&#10;        &#10;        # Initialize skip list and success flag&#10;        if skip_artifacts is None: skip_artifacts = []&#10;        all_artifacts_successful = True&#10;        &#10;        for artifact_name, artifact_config in self.artifact_agents.items():&#10;            if artifact_name in skip_artifacts:  # Check if this artifact should be skipped&#10;                self.logger.print_status(f&quot;Skipping {artifact_name} (--skip-{artifact_name} specified)&quot;)&#10;                continue&#10;            &#10;            self.logger.print_status(f&quot;Generating {artifact_name}...&quot;)&#10;            success = self.artifact_creation_loop(artifact_name, tool_info, planning_data, module_path, status)&#10;            &#10;            if not success:&#10;                self.logger.print_status(f&quot;❌ Failed to generate {artifact_name} after {MAX_ARTIFACT_LOOPS} attempts&quot;)&#10;                all_artifacts_successful = False&#10;        &#10;        return all_artifacts_successful&#10;    &#10;    def print_final_report(self, status: ModuleGenerationStatus):&#10;        &quot;&quot;&quot;Print comprehensive final report&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Final Report&quot;)&#10;        &#10;        print(f&quot;Tool Name: {status.tool_name}&quot;)&#10;        print(f&quot;Module Directory: {status.module_directory}&quot;)&#10;        print(f&quot;Research Complete: {'✓' if status.research_complete else '❌'}&quot;)&#10;        print(f&quot;Planning Complete: {'✓' if status.planning_complete else '❌'}&quot;)&#10;        &#10;        # Print artifact status&#10;        print(f&quot;\nArtifact Status:&quot;)&#10;        for artifact_name, artifact_status in status.artifacts_status.items():&#10;            generated = &quot;✓&quot; if artifact_status['generated'] else &quot;❌&quot;&#10;            validated = &quot;✓&quot; if artifact_status['validated'] else &quot;❌&quot;&#10;            attempts = artifact_status['attempts']&#10;            &#10;            print(f&quot;  {artifact_name}:&quot;)&#10;            print(f&quot;    Generated: {generated} | Validated: {validated} | Attempts: {attempts}&quot;)&#10;            &#10;            if artifact_status['errors']:&#10;                print(f&quot;    Errors: {len(artifact_status['errors'])}&quot;)&#10;                for error in artifact_status['errors'][:2]:  # Show first 2 errors&#10;                    print(f&quot;      - {error}&quot;)&#10;        &#10;        # Print parameters if available&#10;        if status.parameters:&#10;            print(f&quot;\nParameters Identified: {len(status.parameters)}&quot;)&#10;            for i, param in enumerate(status.parameters[:5]):  # Show first 5&#10;                name = param.get('name', 'unknown')&#10;                param_type = param.get('type', 'unknown')&#10;                required = 'Required' if param.get('required', False) else 'Optional'&#10;                print(f&quot;  - {name}: {param_type} ({required})&quot;)&#10;            &#10;            if len(status.parameters) &gt; 5:&#10;                print(f&quot;  ... and {len(status.parameters) - 5} more parameters&quot;)&#10;        &#10;        # Print generated files&#10;        module_path = Path(status.module_directory)&#10;        if module_path.exists():&#10;            print(f&quot;\nGenerated Files:&quot;)&#10;            for file in module_path.iterdir():&#10;                if file.is_file():&#10;                    size = file.stat().st_size&#10;                    print(f&quot;  - {file.name} ({size:,} bytes)&quot;)&#10;        &#10;        # Overall success status&#10;        all_artifacts_valid = all(&#10;            artifact['generated'] and artifact['validated'] &#10;            for artifact in status.artifacts_status.values()&#10;        )&#10;        overall_success = (status.research_complete and &#10;                          status.planning_complete and &#10;                          all_artifacts_valid)&#10;        &#10;        print(f&quot;\n{'='*60}&quot;)&#10;        if overall_success:&#10;            print(&quot; MODULE GENERATION SUCCESSFUL!&quot;)&#10;            print(f&quot;Your GenePattern module is ready in: {status.module_directory}&quot;)&#10;        else:&#10;            print(&quot;❌ MODULE GENERATION FAILED&quot;)&#10;            print(&quot;Check the error messages above for details.&quot;)&#10;            if status.error_messages:&#10;                print(&quot;Errors encountered:&quot;)&#10;                for error in status.error_messages:&#10;                    print(f&quot;  - {error}&quot;)&#10;&#10;    def run(self, tool_info: Dict[str, str], skip_artifacts: List[str] = None, dev_mode: bool = False) -&gt; int:&#10;        &quot;&quot;&quot;Run the complete module generation process&quot;&quot;&quot;&#10;        self.logger.print_status(f&quot;Generating module for: {tool_info['name']}&quot;)&#10;&#10;        # Create module directory&#10;        module_path = self.create_module_directory(tool_info['name'])&#10;&#10;        # Initialize status tracking&#10;        status = ModuleGenerationStatus(tool_name=tool_info['name'], module_directory=str(module_path))&#10;&#10;        # Phase 1: Research&#10;        research_success, research_data = self.do_research(tool_info)&#10;        if research_success: status.research_data = research_data&#10;        else: status.error_messages.append(research_data.get('error', 'Research failed'))&#10;        if dev_mode:&#10;            with open(module_path / &quot;research.md&quot;, &quot;w&quot;) as f:&#10;                f.write(status.research_data.get('research', ''))&#10;&#10;        if not status.research_complete:&#10;            self.print_final_report(status)&#10;            return 1&#10;&#10;        # Phase 2: Planning&#10;        planning_success, planning_data = self.do_planning(tool_info, status.research_data)&#10;        if planning_success: status.planning_data = planning_data&#10;        else: status.error_messages.append(planning_data.get('error', 'Planning failed'))&#10;        if dev_mode:&#10;            with open(module_path / &quot;plan.md&quot;, &quot;w&quot;) as f:&#10;                f.write(status.planning_data.get('plan', ''))&#10;&#10;        if not status.planning_complete:&#10;            self.print_final_report(status)&#10;            return 1&#10;&#10;        # Extract parameters from planning data&#10;        status.parameters = status.planning_data.get('parameters', [])&#10;&#10;        # Phase 3: Artifact Generation&#10;        artifacts_success = self.generate_all_artifacts(tool_info, status.planning_data, module_path, status, skip_artifacts)&#10;&#10;        # Final report&#10;        self.print_final_report(status)&#10;&#10;        return 0 if (research_success and planning_success and artifacts_success) else 1&#10;&#10;&#10;class GenerationScript:&#10;    &quot;&quot;&quot;&#10;    Main script orchestration class for GenePattern module generation.&#10;    Handles user input, argument parsing, and overall script coordination.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;Initialize the generation script&quot;&quot;&quot;&#10;        self.logger = Logger()&#10;        self.args = None&#10;        self.tool_info = None&#10;        self.module_agent = None&#10;        self.skip_artifacts = None&#10;&#10;    def get_user_input(self) -&gt; Dict[str, str]:&#10;        &quot;&quot;&quot;Prompt user for bioinformatics tool information&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;GenePattern Module Generator&quot;)&#10;        print(&quot;This script will help you create a GenePattern module for a bioinformatics tool.&quot;)&#10;        print(&quot;Please provide the following information:\n&quot;)&#10;        &#10;        tool_info = {}&#10;        &#10;        # Required fields&#10;        tool_info['name'] = input(&quot;Tool name (e.g., 'samtools', 'bwa', 'star'): &quot;).strip()&#10;        if not tool_info['name']:&#10;            print(&quot;Error: Tool name is required.&quot;)&#10;            sys.exit(1)&#10;        &#10;        # Optional fields with defaults&#10;        tool_info['version'] = input(&quot;Tool version (optional): &quot;).strip() or &quot;latest&quot;&#10;        tool_info['language'] = input(&quot;Primary language (python/r/java/c/cpp/other, optional): &quot;).strip() or &quot;unknown&quot;&#10;        tool_info['description'] = input(&quot;Brief description (optional): &quot;).strip()&#10;        tool_info['repository_url'] = input(&quot;Repository URL (optional): &quot;).strip()&#10;        tool_info['documentation_url'] = input(&quot;Documentation URL (optional): &quot;).strip()&#10;        &#10;        return tool_info&#10;&#10;    def parse_arguments(self):&#10;        &quot;&quot;&quot;Parse command line arguments&quot;&quot;&quot;&#10;        parser = argparse.ArgumentParser(&#10;            description=&quot;Generate complete GenePattern modules from bioinformatics tool information&quot;,&#10;            formatter_class=argparse.RawDescriptionHelpFormatter,&#10;            epilog=&quot;&quot;&quot;&#10;                Examples:&#10;                  # Generate all artifacts (default)&#10;                  python generate-module.py&#10;                &#10;                  # Skip specific artifacts&#10;                  python generate-module.py --skip-dockerfile --skip-gpunit&#10;                  &#10;                  # Generate only wrapper and manifest&#10;                  python generate-module.py --artifacts wrapper manifest&#10;                  &#10;                  # Skip container-related artifacts for local development&#10;                  python generate-module.py --skip-dockerfile&#10;                &#10;                Available artifacts: wrapper, manifest, paramgroups, gpunit, documentation, dockerfile&#10;            &quot;&quot;&quot;&#10;        )&#10;        &#10;        # Tool information&#10;        parser.add_argument('--name', type=str, help='Tool name (e.g., &quot;samtools&quot;)')&#10;        parser.add_argument('--version', type=str, help='Tool version')&#10;        parser.add_argument('--language', type=str, help='Primary language (e.g., &quot;python&quot;)')&#10;        parser.add_argument('--description', type=str, help='Brief description of the tool')&#10;        parser.add_argument('--repository-url', type=str, help='URL of the source code repository')&#10;        parser.add_argument('--documentation-url', type=str, help='URL of the tool documentation')&#10;&#10;        # Artifact skip flags&#10;        parser.add_argument('--skip-wrapper', action='store_true', help='Skip generating wrapper script')&#10;        parser.add_argument('--skip-manifest', action='store_true', help='Skip generating manifest file')&#10;        parser.add_argument('--skip-paramgroups', action='store_true', help='Skip generating paramgroups.json file')&#10;        parser.add_argument('--skip-gpunit', action='store_true', help='Skip generating GPUnit test file')&#10;        parser.add_argument('--skip-documentation', action='store_true', help='Skip generating README.md documentation')&#10;        parser.add_argument('--skip-dockerfile', action='store_true', help='Skip generating Dockerfile')&#10;        &#10;        # Alternative: specify only artifacts to generate&#10;        parser.add_argument('--artifacts', nargs='+', choices=['wrapper', 'manifest', 'paramgroups', 'gpunit', 'documentation', 'dockerfile', 'none'], help=&quot;Generate only specified artifacts, or 'none' to skip all (alternative to --skip-* flags)&quot;)&#10;&#10;        # Development mode&#10;        parser.add_argument('--dev-mode', action='store_true', help='Enable development mode, saves intermediate files')&#10;&#10;        # Output directory&#10;        parser.add_argument('--output-dir', default=DEFAULT_OUTPUT_DIR, type=str, help=f'Output directory for generated modules (default: {DEFAULT_OUTPUT_DIR})')&#10;        &#10;        self.args = parser.parse_args()&#10;&#10;    def tool_info_from_args(self):&#10;        &quot;&quot;&quot;Extract tool information from command line arguments&quot;&quot;&quot;&#10;        self.tool_info = {&#10;            'name': self.args.name,&#10;            'version': self.args.version or &quot;latest&quot;,&#10;            'language': self.args.language or &quot;unknown&quot;,&#10;            'description': self.args.description or &quot;&quot;,&#10;            'repository_url': self.args.repository_url or &quot;&quot;,&#10;            'documentation_url': self.args.documentation_url or &quot;&quot;&#10;        }&#10;&#10;    def parse_skip_artifacts(self):&#10;        &quot;&quot;&quot;Determine which artifacts to skip based on command line arguments&quot;&quot;&quot;&#10;        self.skip_artifacts = []&#10;        all_artifacts = ['wrapper', 'manifest', 'paramgroups', 'gpunit', 'documentation', 'dockerfile']&#10;&#10;        # If --artifacts specified, skip everything not in the list&#10;        if self.args.artifacts:&#10;            if 'none' in self.args.artifacts:&#10;                self.skip_artifacts = all_artifacts&#10;                self.logger.print_status(&quot;Skipping all artifact generation as '--artifacts none' was specified.&quot;)&#10;            else:&#10;                self.skip_artifacts = [artifact for artifact in all_artifacts if artifact not in self.args.artifacts]&#10;                self.logger.print_status(f&quot;Generating only: {', '.join(self.args.artifacts)}&quot;)&#10;        else:&#10;            # Use individual skip flags&#10;            if self.args.skip_wrapper:       self.skip_artifacts.append('wrapper')&#10;            if self.args.skip_manifest:      self.skip_artifacts.append('manifest')&#10;            if self.args.skip_paramgroups:   self.skip_artifacts.append('paramgroups')&#10;            if self.args.skip_gpunit:        self.skip_artifacts.append('gpunit')&#10;            if self.args.skip_documentation: self.skip_artifacts.append('documentation')&#10;            if self.args.skip_dockerfile:    self.skip_artifacts.append('dockerfile')&#10;&#10;            if self.skip_artifacts:          self.logger.print_status(f&quot;Skipping: {', '.join(self.skip_artifacts)}&quot;)&#10;&#10;    def main(self):&#10;        &quot;&quot;&quot;Main entry point for module generation&quot;&quot;&quot;&#10;        try:&#10;            # Parse command line arguments&#10;            self.parse_arguments()&#10;            self.parse_skip_artifacts()&#10;&#10;            # Get tool information from args or user input&#10;            if self.args.name: self.tool_info_from_args()&#10;            else: self.tool_info = self.get_user_input()&#10;&#10;            # Initialize ModuleAgent with logger and module directory&#10;            self.module_agent = ModuleAgent(self.logger, self.args.output_dir)&#10;&#10;            # Run the generation process&#10;            return self.module_agent.run(self.tool_info, self.skip_artifacts, self.args.dev_mode)&#10;&#10;        except KeyboardInterrupt:&#10;            self.logger.print_status(&quot;\nGeneration interrupted by user&quot;, &quot;WARNING&quot;)&#10;            return 1&#10;        except Exception as e:&#10;            self.logger.print_status(f&quot;Unexpected error: {str(e)}&quot;, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return 1&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    script = GenerationScript()&#10;    sys.exit(script.main())&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;GenePattern Module Generator&#10;&#10;A multi-agent system for automatically generating GenePattern modules from bioinformatics tools.&#10;Uses Pydantic AI to orchestrate research, planning, and artifact generation.&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import traceback&#10;import argparse&#10;from pathlib import Path&#10;from typing import Dict, List, Tuple, Any&#10;from dataclasses import dataclass&#10;from datetime import datetime&#10;&#10;from pydantic_ai import Agent&#10;from pydantic_ai.mcp import MCPServerStdio&#10;from dotenv import load_dotenv&#10;&#10;&#10;# Load environment variables from .env file&#10;load_dotenv()&#10;&#10;&#10;# Import agents&#10;from agents.researcher import researcher_agent&#10;from agents.planner import planner_agent&#10;from wrapper.agent import wrapper_agent&#10;from dockerfile.agent import dockerfile_agent&#10;from paramgroups.agent import paramgroups_agent&#10;from manifest.agent import manifest_agent&#10;from documentation.agent import documentation_agent&#10;from gpunit.agent import gpunit_agent&#10;&#10;&#10;# Configuration&#10;MAX_ARTIFACT_LOOPS = int(os.getenv('MAX_ARTIFACT_LOOPS', '5'))&#10;DEFAULT_OUTPUT_DIR = os.getenv('MODULE_OUTPUT_DIR', './generated-modules')&#10;&#10;&#10;class Logger:&#10;    &quot;&quot;&quot;Logging and display utilities for the module generation process.&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def print_status(message: str, level: str = &quot;INFO&quot;):&#10;        &quot;&quot;&quot;Print status message with timestamp and level&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%H:%M:%S&quot;)&#10;        print(f&quot;[{timestamp}] {level}: {message}&quot;)&#10;&#10;    @staticmethod&#10;    def print_section(title: str):&#10;        &quot;&quot;&quot;Print a section header&quot;&quot;&quot;&#10;        print(&quot;\n&quot; + &quot;=&quot; * 60)&#10;        print(f&quot; {title}&quot;)&#10;        print(&quot;=&quot; * 60)&#10;&#10;&#10;# Status tracking&#10;@dataclass&#10;class ModuleGenerationStatus:&#10;    &quot;&quot;&quot;Track the status of module generation process&quot;&quot;&quot;&#10;    tool_name: str&#10;    module_directory: str&#10;    research_data: Dict[str, Any] = None&#10;    planning_data: Dict[str, Any] = None&#10;    artifacts_status: Dict[str, Dict[str, Any]] = None&#10;    parameters: List[Dict[str, Any]] = None&#10;    error_messages: List[str] = None&#10;&#10;    def __post_init__(self):&#10;        if self.artifacts_status is None: self.artifacts_status = {}&#10;        if self.parameters is None: self.parameters = []&#10;        if self.error_messages is None: self.error_messages = []&#10;        if self.research_data is None: self.research_data = {}&#10;        if self.planning_data is None: self.planning_data = {}&#10;&#10;    @property&#10;    def research_complete(self) -&gt; bool:&#10;        &quot;&quot;&quot;Return True if research data is present&quot;&quot;&quot;&#10;        return bool(self.research_data)&#10;&#10;    @property&#10;    def planning_complete(self) -&gt; bool:&#10;        &quot;&quot;&quot;Return True if planning data is present&quot;&quot;&quot;&#10;        return bool(self.planning_data)&#10;&#10;&#10;class ModuleAgent:&#10;    &quot;&quot;&quot;&#10;    Main orchestrator agent for GenePattern module generation.&#10;    Groups all methods for calling other agents, validation, and reporting.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self, logger: Logger = None, output_dir: str = DEFAULT_OUTPUT_DIR):&#10;        &quot;&quot;&quot;Initialize the module agent with MCP server for validation&quot;&quot;&quot;&#10;        self.logger = logger or Logger()&#10;        self.output_dir = output_dir&#10;&#10;        # Define artifact agents mapping&#10;        self.artifact_agents = {&#10;            'wrapper': {&#10;                'agent': wrapper_agent,&#10;                'filename': 'wrapper.py',&#10;                'validate_tool': 'validate_wrapper',&#10;                'create_method': 'create_wrapper'&#10;            },&#10;            'manifest': {&#10;                'agent': manifest_agent,&#10;                'filename': 'manifest',&#10;                'validate_tool': 'validate_manifest',&#10;                'create_method': 'create_manifest'&#10;            },&#10;            'paramgroups': {&#10;                'agent': paramgroups_agent,&#10;                'filename': 'paramgroups.json',&#10;                'validate_tool': 'validate_paramgroups',&#10;                'create_method': 'create_paramgroups'&#10;            },&#10;            'gpunit': {&#10;                'agent': gpunit_agent,&#10;                'filename': 'test.yml',&#10;                'validate_tool': 'validate_gpunit',&#10;                'create_method': 'create_gpunit'&#10;            },&#10;            'documentation': {&#10;                'agent': documentation_agent,&#10;                'filename': 'README.md',&#10;                'validate_tool': 'validate_documentation',&#10;                'create_method': 'create_documentation'&#10;            },&#10;            'dockerfile': {&#10;                'agent': dockerfile_agent,&#10;                'filename': 'Dockerfile',&#10;                'validate_tool': 'validate_dockerfile',&#10;                'create_method': 'create_dockerfile'&#10;            }&#10;        }&#10;    &#10;    def create_module_directory(self, tool_name: str) -&gt; Path:&#10;        &quot;&quot;&quot;Create and return the module directory path&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        tool_name_clean = tool_name.lower().replace(' ', '_').replace('-', '_')&#10;        module_dir_name = f&quot;{tool_name_clean}_{timestamp}&quot;&#10;        module_path = Path(self.output_dir) / module_dir_name&#10;&#10;        self.logger.print_status(f&quot;Creating module directory: {module_path}&quot;)&#10;        module_path.mkdir(parents=True, exist_ok=True)&#10;        return module_path&#10;    &#10;    def do_research(self, tool_info: Dict[str, str]) -&gt; Tuple[bool, Dict[str, Any]]:&#10;        &quot;&quot;&quot;Run research phase using researcher agent&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Research Phase&quot;)&#10;        self.logger.print_status(&quot;Starting research on tool information&quot;)&#10;        &#10;        try:&#10;            prompt = f&quot;&quot;&quot;&#10;            Research the bioinformatics tool '{tool_info['name']}' and provide comprehensive information.&#10;            &#10;            Known Information:&#10;            - Name: {tool_info['name']}&#10;            - Version: {tool_info['version']}&#10;            - Language: {tool_info['language']}&#10;            - Description: {tool_info.get('description', 'Not provided')}&#10;            - Repository: {tool_info.get('repository_url', 'Not provided')}&#10;            - Documentation: {tool_info.get('documentation_url', 'Not provided')}&#10;            &#10;            Please provide detailed research including:&#10;            1. Tool purpose and scientific applications&#10;            2. Input/output formats and requirements&#10;            3. Parameter analysis and usage patterns&#10;            4. Installation and dependency requirements&#10;            5. Common workflows and use cases&#10;            6. Integration considerations for GenePattern&#10;            &#10;            Focus on information that will help create a complete GenePattern module.&#10;            &quot;&quot;&quot;&#10;            &#10;            result = researcher_agent.run_sync(prompt)&#10;            self.logger.print_status(&quot;Research phase completed successfully&quot;, &quot;SUCCESS&quot;)&#10;            return True, {'research': result.output}&#10;            &#10;        except Exception as e:&#10;            error_msg = f&quot;Research phase failed: {str(e)}&quot;&#10;            self.logger.print_status(error_msg, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return False, {'error': error_msg}&#10;    &#10;    def do_planning(self, tool_info: Dict[str, str], research_data: Dict[str, Any]) -&gt; Tuple[bool, Dict[str, Any]]:&#10;        &quot;&quot;&quot;Run planning phase using planner agent&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Planning Phase&quot;)&#10;        self.logger.print_status(&quot;Starting module planning and parameter analysis&quot;)&#10;        &#10;        try:&#10;            prompt = f&quot;&quot;&quot;&#10;            Create a comprehensive plan for the GenePattern module for '{tool_info['name']}'.&#10;            &#10;            Tool Information:&#10;            - Name: {tool_info['name']}&#10;            - Version: {tool_info['version']}&#10;            - Language: {tool_info['language']}&#10;            - Description: {tool_info.get('description', 'Not provided')}&#10;            &#10;            Research Results:&#10;            {research_data.get('research', 'No research data available')}&#10;            &#10;            Please create:&#10;            1. Detailed parameter definitions with types and descriptions&#10;            2. Module architecture recommendations&#10;            3. Integration strategy for GenePattern&#10;            4. Validation and testing approach&#10;            5. Implementation roadmap&#10;            &#10;            Focus on creating actionable specifications for module development.&#10;            &quot;&quot;&quot;&#10;            &#10;            result = planner_agent.run_sync(prompt)&#10;            self.logger.print_status(&quot;Planning phase completed successfully&quot;, &quot;SUCCESS&quot;)&#10;            return True, {'plan': result.output, 'parameters': []}  # Parameters would be extracted from plan&#10;            &#10;        except Exception as e:&#10;            error_msg = f&quot;Planning phase failed: {str(e)}&quot;&#10;            self.logger.print_status(error_msg, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return False, {'error': error_msg}&#10;    &#10;    def artifact_creation_loop(self, artifact_name: str, tool_info: Dict[str, str], planning_data: Dict[str, Any], module_path: Path, status: ModuleGenerationStatus) -&gt; bool:&#10;        &quot;&quot;&quot;Generate and validate a single artifact using its dedicated agent&quot;&quot;&quot;&#10;        artifact_config = self.artifact_agents[artifact_name]&#10;        agent = artifact_config['agent']&#10;        filename = artifact_config['filename']&#10;        validate_tool = artifact_config['validate_tool']&#10;        create_method = artifact_config['create_method']&#10;        file_path = module_path / filename&#10;        error_report = &quot;&quot;&#10;&#10;        # Initialize artifact status&#10;        status.artifacts_status[artifact_name] = {&#10;            'generated': False,&#10;            'validated': False,&#10;            'attempts': 0,&#10;            'errors': []&#10;        }&#10;&#10;        for attempt in range(1, MAX_ARTIFACT_LOOPS + 1):&#10;            try:&#10;                self.logger.print_status(f&quot;Generating {artifact_name} (attempt {attempt}/{MAX_ARTIFACT_LOOPS})&quot;)&#10;                status.artifacts_status[artifact_name]['attempts'] = attempt&#10;&#10;                # Call the agent's create method with proper parameters&#10;                prompt = f&quot;&quot;&quot;Use the {create_method} tool with the following parameters:&#10;                - tool_info: {tool_info}&#10;                - planning_data: {planning_data}&#10;                - error_report: {error_report}&#10;                - attempt: {attempt}&#10;&#10;                Generate the {artifact_name} artifact for {tool_info['name']}.&quot;&quot;&quot;&#10;                result = agent.run_sync(prompt)&#10;&#10;                # Write content to file&#10;                with open(file_path, 'w') as f:&#10;                    f.write(result.output)&#10;&#10;                status.artifacts_status[artifact_name]['generated'] = True&#10;                self.logger.print_status(f&quot;Generated {filename}&quot;)&#10;&#10;                # Validate using MCP server&#10;                validation_result = self.validate_artifact(str(file_path), validate_tool)&#10;&#10;                if validation_result['success']:&#10;                    status.artifacts_status[artifact_name]['validated'] = True&#10;                    self.logger.print_status(f&quot;✅ Successfully generated and validated {artifact_name}&quot;)&#10;                    return True&#10;                else:&#10;                    error_report = f&quot;Validation failed: {validation_result.get('error', 'Unknown validation error')}&quot;&#10;                    self.logger.print_status(f&quot;❌ {error_report}&quot;)&#10;                    status.artifacts_status[artifact_name]['errors'].append(error_report)&#10;&#10;                    if attempt == MAX_ARTIFACT_LOOPS:&#10;                        return False&#10;&#10;            except Exception as e:&#10;                error_report = f&quot;Error generating {artifact_name}: {str(e)}&quot;&#10;                self.logger.print_status(error_report, &quot;ERROR&quot;)&#10;                status.artifacts_status[artifact_name]['errors'].append(error_report)&#10;&#10;                if attempt == MAX_ARTIFACT_LOOPS:&#10;                    return False&#10;&#10;        return False&#10;&#10;    def validate_artifact(self, file_path: str, validate_tool: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Validate an artifact using the MCP server&quot;&quot;&quot;&#10;        try:&#10;            self.logger.print_status(f&quot;Validating with {validate_tool}&quot;)&#10;&#10;            # Create a temporary agent with MCP tools to run validation&#10;            validation_agent = Agent(&#10;                model='bedrock:us.anthropic.claude-sonnet-4-20250514-v1:0',&#10;                toolsets=[MCPServerStdio('python', args=['mcp/server.py'], timeout=10)]&#10;            )&#10;&#10;            # Use the agent to call the validation tool&#10;            prompt = f&quot;Use the {validate_tool} tool to validate the file at path: {file_path}&quot;&#10;            result = validation_agent.run_sync(prompt)&#10;&#10;            # Parse the validation output more carefully&#10;            output = result.output&#10;            self.logger.print_status(f&quot;Validation output: {output[:200]}...&quot;)  # Log first 200 chars for debugging&#10;            &#10;            # Look for explicit PASS/FAIL indicators from the linter&#10;            output_lower = output.lower()&#10;            &#10;            # Check for explicit failure indicators&#10;            if any(indicator in output_lower for indicator in [&#10;                &quot;fail:&quot;, &quot;failed&quot;, &quot;error:&quot;, &quot;invalid json&quot;, &quot;validation failed&quot;&#10;            ]):&#10;                return {'success': False, 'error': output}&#10;            &#10;            # Check for explicit success indicators&#10;            elif any(indicator in output_lower for indicator in [&#10;                &quot;pass:&quot;, &quot;passed all validation&quot;, &quot;validation passed&quot;&#10;            ]):&#10;                return {'success': True, 'result': output}&#10;            &#10;            # If we can't determine success/failure clearly, default to failure for safety&#10;            else:&#10;                self.logger.print_status(f&quot;Ambiguous validation result, defaulting to failure&quot;, &quot;WARNING&quot;)&#10;                return {'success': False, 'error': f&quot;Ambiguous validation result: {output}&quot;}&#10;                &#10;        except Exception as e:&#10;            return {'success': False, 'error': f&quot;Validation error: {str(e)}&quot;}&#10;&#10;    def generate_all_artifacts(self, tool_info: Dict[str, str], planning_data: Dict[str, Any], module_path: Path, status: ModuleGenerationStatus, skip_artifacts: List[str] = None) -&gt; bool:&#10;        &quot;&quot;&quot;Run artifact generation phase using artifact agents&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Artifact Generation Phase&quot;)&#10;        self.logger.print_status(&quot;Starting artifact generation&quot;)&#10;        &#10;        # Initialize skip list and success flag&#10;        if skip_artifacts is None: skip_artifacts = []&#10;        all_artifacts_successful = True&#10;        &#10;        for artifact_name, artifact_config in self.artifact_agents.items():&#10;            if artifact_name in skip_artifacts:  # Check if this artifact should be skipped&#10;                self.logger.print_status(f&quot;Skipping {artifact_name} (--skip-{artifact_name} specified)&quot;)&#10;                continue&#10;            &#10;            self.logger.print_status(f&quot;Generating {artifact_name}...&quot;)&#10;            success = self.artifact_creation_loop(artifact_name, tool_info, planning_data, module_path, status)&#10;            &#10;            if not success:&#10;                self.logger.print_status(f&quot;❌ Failed to generate {artifact_name} after {MAX_ARTIFACT_LOOPS} attempts&quot;)&#10;                all_artifacts_successful = False&#10;        &#10;        return all_artifacts_successful&#10;    &#10;    def print_final_report(self, status: ModuleGenerationStatus):&#10;        &quot;&quot;&quot;Print comprehensive final report&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;Final Report&quot;)&#10;        &#10;        print(f&quot;Tool Name: {status.tool_name}&quot;)&#10;        print(f&quot;Module Directory: {status.module_directory}&quot;)&#10;        print(f&quot;Research Complete: {'✓' if status.research_complete else '❌'}&quot;)&#10;        print(f&quot;Planning Complete: {'✓' if status.planning_complete else '❌'}&quot;)&#10;        &#10;        # Print artifact status&#10;        print(f&quot;\nArtifact Status:&quot;)&#10;        for artifact_name, artifact_status in status.artifacts_status.items():&#10;            generated = &quot;✓&quot; if artifact_status['generated'] else &quot;❌&quot;&#10;            validated = &quot;✓&quot; if artifact_status['validated'] else &quot;❌&quot;&#10;            attempts = artifact_status['attempts']&#10;            &#10;            print(f&quot;  {artifact_name}:&quot;)&#10;            print(f&quot;    Generated: {generated} | Validated: {validated} | Attempts: {attempts}&quot;)&#10;            &#10;            if artifact_status['errors']:&#10;                print(f&quot;    Errors: {len(artifact_status['errors'])}&quot;)&#10;                for error in artifact_status['errors'][:2]:  # Show first 2 errors&#10;                    print(f&quot;      - {error}&quot;)&#10;        &#10;        # Print parameters if available&#10;        if status.parameters:&#10;            print(f&quot;\nParameters Identified: {len(status.parameters)}&quot;)&#10;            for i, param in enumerate(status.parameters[:5]):  # Show first 5&#10;                name = param.get('name', 'unknown')&#10;                param_type = param.get('type', 'unknown')&#10;                required = 'Required' if param.get('required', False) else 'Optional'&#10;                print(f&quot;  - {name}: {param_type} ({required})&quot;)&#10;            &#10;            if len(status.parameters) &gt; 5:&#10;                print(f&quot;  ... and {len(status.parameters) - 5} more parameters&quot;)&#10;        &#10;        # Print generated files&#10;        module_path = Path(status.module_directory)&#10;        if module_path.exists():&#10;            print(f&quot;\nGenerated Files:&quot;)&#10;            for file in module_path.iterdir():&#10;                if file.is_file():&#10;                    size = file.stat().st_size&#10;                    print(f&quot;  - {file.name} ({size:,} bytes)&quot;)&#10;        &#10;        # Overall success status&#10;        all_artifacts_valid = all(&#10;            artifact['generated'] and artifact['validated'] &#10;            for artifact in status.artifacts_status.values()&#10;        )&#10;        overall_success = (status.research_complete and &#10;                          status.planning_complete and &#10;                          all_artifacts_valid)&#10;        &#10;        print(f&quot;\n{'='*60}&quot;)&#10;        if overall_success:&#10;            print(&quot; MODULE GENERATION SUCCESSFUL!&quot;)&#10;            print(f&quot;Your GenePattern module is ready in: {status.module_directory}&quot;)&#10;        else:&#10;            print(&quot;❌ MODULE GENERATION FAILED&quot;)&#10;            print(&quot;Check the error messages above for details.&quot;)&#10;            if status.error_messages:&#10;                print(&quot;Errors encountered:&quot;)&#10;                for error in status.error_messages:&#10;                    print(f&quot;  - {error}&quot;)&#10;&#10;    def run(self, tool_info: Dict[str, str], skip_artifacts: List[str] = None, dev_mode: bool = False) -&gt; int:&#10;        &quot;&quot;&quot;Run the complete module generation process&quot;&quot;&quot;&#10;        self.logger.print_status(f&quot;Generating module for: {tool_info['name']}&quot;)&#10;&#10;        # Create module directory&#10;        module_path = self.create_module_directory(tool_info['name'])&#10;&#10;        # Initialize status tracking&#10;        status = ModuleGenerationStatus(tool_name=tool_info['name'], module_directory=str(module_path))&#10;&#10;        # Phase 1: Research&#10;        research_success, research_data = self.do_research(tool_info)&#10;        if research_success: status.research_data = research_data&#10;        else: status.error_messages.append(research_data.get('error', 'Research failed'))&#10;        if dev_mode:&#10;            with open(module_path / &quot;research.md&quot;, &quot;w&quot;) as f:&#10;                f.write(status.research_data.get('research', ''))&#10;&#10;        if not status.research_complete:&#10;            self.print_final_report(status)&#10;            return 1&#10;&#10;        # Phase 2: Planning&#10;        planning_success, planning_data = self.do_planning(tool_info, status.research_data)&#10;        if planning_success: status.planning_data = planning_data&#10;        else: status.error_messages.append(planning_data.get('error', 'Planning failed'))&#10;        if dev_mode:&#10;            with open(module_path / &quot;plan.md&quot;, &quot;w&quot;) as f:&#10;                f.write(status.planning_data.get('plan', ''))&#10;&#10;        if not status.planning_complete:&#10;            self.print_final_report(status)&#10;            return 1&#10;&#10;        # Extract parameters from planning data&#10;        status.parameters = status.planning_data.get('parameters', [])&#10;&#10;        # Phase 3: Artifact Generation&#10;        artifacts_success = self.generate_all_artifacts(tool_info, status.planning_data, module_path, status, skip_artifacts)&#10;&#10;        # Final report&#10;        self.print_final_report(status)&#10;&#10;        return 0 if (research_success and planning_success and artifacts_success) else 1&#10;&#10;&#10;class GenerationScript:&#10;    &quot;&quot;&quot;&#10;    Main script orchestration class for GenePattern module generation.&#10;    Handles user input, argument parsing, and overall script coordination.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;Initialize the generation script&quot;&quot;&quot;&#10;        self.logger = Logger()&#10;        self.args = None&#10;        self.tool_info = None&#10;        self.module_agent = None&#10;        self.skip_artifacts = None&#10;&#10;    def get_user_input(self) -&gt; Dict[str, str]:&#10;        &quot;&quot;&quot;Prompt user for bioinformatics tool information&quot;&quot;&quot;&#10;        self.logger.print_section(&quot;GenePattern Module Generator&quot;)&#10;        print(&quot;This script will help you create a GenePattern module for a bioinformatics tool.&quot;)&#10;        print(&quot;Please provide the following information:\n&quot;)&#10;        &#10;        tool_info = {}&#10;        &#10;        # Required fields&#10;        tool_info['name'] = input(&quot;Tool name (e.g., 'samtools', 'bwa', 'star'): &quot;).strip()&#10;        if not tool_info['name']:&#10;            print(&quot;Error: Tool name is required.&quot;)&#10;            sys.exit(1)&#10;        &#10;        # Optional fields with defaults&#10;        tool_info['version'] = input(&quot;Tool version (optional): &quot;).strip() or &quot;latest&quot;&#10;        tool_info['language'] = input(&quot;Primary language (python/r/java/c/cpp/other, optional): &quot;).strip() or &quot;unknown&quot;&#10;        tool_info['description'] = input(&quot;Brief description (optional): &quot;).strip()&#10;        tool_info['repository_url'] = input(&quot;Repository URL (optional): &quot;).strip()&#10;        tool_info['documentation_url'] = input(&quot;Documentation URL (optional): &quot;).strip()&#10;        &#10;        return tool_info&#10;&#10;    def parse_arguments(self):&#10;        &quot;&quot;&quot;Parse command line arguments&quot;&quot;&quot;&#10;        parser = argparse.ArgumentParser(&#10;            description=&quot;Generate complete GenePattern modules from bioinformatics tool information&quot;,&#10;            formatter_class=argparse.RawDescriptionHelpFormatter,&#10;            epilog=&quot;&quot;&quot;&#10;                Examples:&#10;                  # Generate all artifacts (default)&#10;                  python generate-module.py&#10;                &#10;                  # Skip specific artifacts&#10;                  python generate-module.py --skip-dockerfile --skip-gpunit&#10;                  &#10;                  # Generate only wrapper and manifest&#10;                  python generate-module.py --artifacts wrapper manifest&#10;                  &#10;                  # Skip container-related artifacts for local development&#10;                  python generate-module.py --skip-dockerfile&#10;                &#10;                Available artifacts: wrapper, manifest, paramgroups, gpunit, documentation, dockerfile&#10;            &quot;&quot;&quot;&#10;        )&#10;        &#10;        # Tool information&#10;        parser.add_argument('--name', type=str, help='Tool name (e.g., &quot;samtools&quot;)')&#10;        parser.add_argument('--version', type=str, help='Tool version')&#10;        parser.add_argument('--language', type=str, help='Primary language (e.g., &quot;python&quot;)')&#10;        parser.add_argument('--description', type=str, help='Brief description of the tool')&#10;        parser.add_argument('--repository-url', type=str, help='URL of the source code repository')&#10;        parser.add_argument('--documentation-url', type=str, help='URL of the tool documentation')&#10;&#10;        # Artifact skip flags&#10;        parser.add_argument('--skip-wrapper', action='store_true', help='Skip generating wrapper script')&#10;        parser.add_argument('--skip-manifest', action='store_true', help='Skip generating manifest file')&#10;        parser.add_argument('--skip-paramgroups', action='store_true', help='Skip generating paramgroups.json file')&#10;        parser.add_argument('--skip-gpunit', action='store_true', help='Skip generating GPUnit test file')&#10;        parser.add_argument('--skip-documentation', action='store_true', help='Skip generating README.md documentation')&#10;        parser.add_argument('--skip-dockerfile', action='store_true', help='Skip generating Dockerfile')&#10;        &#10;        # Alternative: specify only artifacts to generate&#10;        parser.add_argument('--artifacts', nargs='+', choices=['wrapper', 'manifest', 'paramgroups', 'gpunit', 'documentation', 'dockerfile', 'none'], help=&quot;Generate only specified artifacts, or 'none' to skip all (alternative to --skip-* flags)&quot;)&#10;&#10;        # Development mode&#10;        parser.add_argument('--dev-mode', action='store_true', help='Enable development mode, saves intermediate files')&#10;&#10;        # Output directory&#10;        parser.add_argument('--output-dir', default=DEFAULT_OUTPUT_DIR, type=str, help=f'Output directory for generated modules (default: {DEFAULT_OUTPUT_DIR})')&#10;        &#10;        self.args = parser.parse_args()&#10;&#10;    def tool_info_from_args(self):&#10;        &quot;&quot;&quot;Extract tool information from command line arguments&quot;&quot;&quot;&#10;        self.tool_info = {&#10;            'name': self.args.name,&#10;            'version': self.args.version or &quot;latest&quot;,&#10;            'language': self.args.language or &quot;unknown&quot;,&#10;            'description': self.args.description or &quot;&quot;,&#10;            'repository_url': self.args.repository_url or &quot;&quot;,&#10;            'documentation_url': self.args.documentation_url or &quot;&quot;&#10;        }&#10;&#10;    def parse_skip_artifacts(self):&#10;        &quot;&quot;&quot;Determine which artifacts to skip based on command line arguments&quot;&quot;&quot;&#10;        self.skip_artifacts = []&#10;        all_artifacts = ['wrapper', 'manifest', 'paramgroups', 'gpunit', 'documentation', 'dockerfile']&#10;&#10;        # If --artifacts specified, skip everything not in the list&#10;        if self.args.artifacts:&#10;            if 'none' in self.args.artifacts:&#10;                self.skip_artifacts = all_artifacts&#10;                self.logger.print_status(&quot;Skipping all artifact generation as '--artifacts none' was specified.&quot;)&#10;            else:&#10;                self.skip_artifacts = [artifact for artifact in all_artifacts if artifact not in self.args.artifacts]&#10;                self.logger.print_status(f&quot;Generating only: {', '.join(self.args.artifacts)}&quot;)&#10;        else:&#10;            # Use individual skip flags&#10;            if self.args.skip_wrapper:       self.skip_artifacts.append('wrapper')&#10;            if self.args.skip_manifest:      self.skip_artifacts.append('manifest')&#10;            if self.args.skip_paramgroups:   self.skip_artifacts.append('paramgroups')&#10;            if self.args.skip_gpunit:        self.skip_artifacts.append('gpunit')&#10;            if self.args.skip_documentation: self.skip_artifacts.append('documentation')&#10;            if self.args.skip_dockerfile:    self.skip_artifacts.append('dockerfile')&#10;&#10;            if self.skip_artifacts:          self.logger.print_status(f&quot;Skipping: {', '.join(self.skip_artifacts)}&quot;)&#10;&#10;    def main(self):&#10;        &quot;&quot;&quot;Main entry point for module generation&quot;&quot;&quot;&#10;        try:&#10;            # Parse command line arguments&#10;            self.parse_arguments()&#10;            self.parse_skip_artifacts()&#10;&#10;            # Get tool information from args or user input&#10;            if self.args.name: self.tool_info_from_args()&#10;            else: self.tool_info = self.get_user_input()&#10;&#10;            # Initialize ModuleAgent with logger and module directory&#10;            self.module_agent = ModuleAgent(self.logger, self.args.output_dir)&#10;&#10;            # Run the generation process&#10;            return self.module_agent.run(self.tool_info, self.skip_artifacts, self.args.dev_mode)&#10;&#10;        except KeyboardInterrupt:&#10;            self.logger.print_status(&quot;\nGeneration interrupted by user&quot;, &quot;WARNING&quot;)&#10;            return 1&#10;        except Exception as e:&#10;            self.logger.print_status(f&quot;Unexpected error: {str(e)}&quot;, &quot;ERROR&quot;)&#10;            self.logger.print_status(f&quot;Traceback: {traceback.format_exc()}&quot;, &quot;DEBUG&quot;)&#10;            return 1&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    script = GenerationScript()&#10;    sys.exit(script.main())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>